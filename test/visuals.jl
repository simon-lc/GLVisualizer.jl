@testset "visuals" begin
    # create and open a visualizer
    resolution = (600, 400)
    vis = GLVisualizer.Visualizer(resolution=resolution)

    # set a floor object
    GLVisualizer.set_floor!(vis, color=GLVisualizer.RGBA(0.4, 0.4, 0.4, 0.2))

    # create two objects
    object1 = GLVisualizer.HyperRectangle(GLVisualizer.Vec(0,0,0), GLVisualizer.Vec(0.2, 0.9, 1))
    object2 = GLVisualizer.HyperRectangle(GLVisualizer.Vec(0,0,0), GLVisualizer.Vec(0.6, 0.2, 2.0))

    # add both objects to the scene
    # this defines a tree representation: root -> object1 -> object2
    # moving the frame of object1 will move object2 accordingly
    GLVisualizer.setobject!(vis, :root, :object1, object1, color=GLVisualizer.RGBA(0,0,1,0.4))
    GLVisualizer.setobject!(vis, :object1, :object2, object2, color=GLVisualizer.RGBA(1,0,0,0.4))

    # set the camera position, the point we are looking at and the upward direction of the camera.
    eyeposition = [0,2,5.0]
    lookat = [1,0,0.0]
    up = [0,0,1.0]

    GLVisualizer.set_camera!(vis;
    		eyeposition=eyeposition,
    		lookat=lookat,
    		up=up,
    		far=100.0,
    		near=0.1,
    		zoom=1.0,
    		)

    # set the pose of both objects
    GLVisualizer.settransform!(vis, :object1, [0,0,0.50], GLVisualizer.Quaternion(0,0,0,1.0))
    GLVisualizer.settransform!(vis, :object2, [0,0,0.25], GLVisualizer.Quaternion(0,0,0,1.0))

    # compute depth for each pixel in the image generated by the camera
    depth = GLVisualizer.depth_buffer(vis)
    maximum(depth)
    @test minimum(depth) >= 0.0

    # in-place version of the depth query, this still allocates memory though
    depth = GLVisualizer.depth_buffer!(depth, vis)
    maximum(depth)
    @test minimum(depth) >= 0.0

    # convert depth pixels to 3D coordinates in the world frame and sotre them in wolrd_coordinates
    p1 = Vector(range(200, step=32, length=10))
    p2 = Vector(range(100, step=32, length=10))
    n1 = length(p1)
    n2 = length(p2)
    world_coordinates = zeros(3, n1 * n2)
    GLVisualizer.depthpixel_to_world!(world_coordinates, depth, p1, p2, vis)

    # create a pixel object to visualize where it is positioned in 3D space
    pixel_object = GLVisualizer.HyperSphere(GLVisualizer.Point{3}(0,0,0.0), 0.05)
    # place the pixels
    for i = 1:size(world_coordinates, 2)
    	GLVisualizer.setobject!(vis, :root, Symbol(:pixel, i), pixel_object, color=GLVisualizer.RGBA(0.0,0.0,0.0,1.0))
    	GLVisualizer.settransform!(vis, Symbol(:pixel, i), world_coordinates[:,i], GLVisualizer.Quaternion(0,0,0,1.0))
    end
    # all pixels should have landed above the ground
    @test all(world_coordinates[3, :] .>= -1e-3)
end
